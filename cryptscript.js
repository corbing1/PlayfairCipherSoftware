function checkButton() { //this function will run when the check button is clicked
	generated.value = ""; //resets the generated value so it is made clear when something succeeds or not succeeds
	if (plain.value == '' || cipher.value == '') { //checks to make sure the two textboxes are occupied
		window.alert("The plaintext and/or ciphertext textboxes are empty."); 
		return; //if one or both are empty, then the program notifies the user and exits the function early
	}
	if(makeSquare()) //runs the makeSquare function which will make the square and return a boolean
		encipher(); //if the square was successfully made, then the encipher function can run
}

function encipher() { //enciphers the inputted plaintext to compare it to the ciphertext
	let inArr = strToBlocks(plain.value, false);
	let outArr = [];
	for (let i = 0; i < inArr.length; i++) {
		let firstLetterCoords = findLetter(inArr[i].charAt(0));
		let secondLetterCoords = findLetter(inArr[i].charAt(1));
		let firstLetterCoordsEn = -1; //these are the coordinates for the enciphered letters. -1 is a temporary value.
		let secondLetterCoordsEn = -1;
		if (firstLetterCoords[0] == secondLetterCoords[0]) { //checks if the row is the same
			firstLetterCoordsEn = [firstLetterCoords[0], (firstLetterCoords[1]+1) % 5]; //the coordinate is incremented by one
			secondLetterCoordsEn = [secondLetterCoords[0], (secondLetterCoords[1]+1) % 5]; //it is then modded by 5 to ensure it stays within acceptable range
		} else if (firstLetterCoords[1] == secondLetterCoords[1]) { //checks if the column is the same
			firstLetterCoordsEn = [(firstLetterCoords[0]+1) % 5, firstLetterCoords[1]];
			secondLetterCoordsEn = [(secondLetterCoords[0]+1) % 5, secondLetterCoords[1]];
		} else { //runs if neither the row or the column are the same
			firstLetterCoordsEn = [firstLetterCoords[0], secondLetterCoords[1]]; //the column number is switched between the first and second letter
			secondLetterCoordsEn = [secondLetterCoords[0], firstLetterCoords[1]];
		}
		outArr.push(square[firstLetterCoordsEn[0]][firstLetterCoordsEn[1]] + square[secondLetterCoordsEn[0]][secondLetterCoordsEn[1]]);
		//takes the new coordinates and gets the characters found at those coordinates. This will be the enciphered block.
	}
	let comparisonResult = compareUserToGen(outArr, inArr);
	if (comparisonResult) //checks to see if the output of the compareUserToGen function resulted in false or a string
		window.alert(comparisonResult); //if it was a string, the string is alerted to the user, otherwise it does nothing as an alert was already given
	generated.value = outArr.join(" "); //writes the generated ciphertext to the generated ciphertext textbox
}

function compareUserToGen(arrToCompare, plainArr) { //compares the ciphertext generated by the program and the ciphertext provided by the user
	let reportString = ""; //this string will contain a report in the event of a failure
	let failureTriggered = false; //this boolean will determine if the above string is displayed or not
	let limit = 0; //this determines the number of iterations of the loop
	let plainLonger = false; //this will tell the program if the plaintext was longer which likely means an error
	//if the ciphertext is longer than the plaintext, it most likely indicates a crib
	correctArr = strToBlocks(cipher.value, true); //the user-provided ciphertext is considered correct
	if (!correctArr) //strToBlocks outputs false rather than an array if the ciphertext had a double block. This ensures nothing gets outputted.
		return false;
	if (arrToCompare.length > correctArr.length) { //checks if the plaintext is longer than the ciphertext
		limit = correctArr.length; 
		plainLonger = true;
	} else {
		limit = arrToCompare.length; 
	}
	for (let i = 0; i < limit; i++) {
		if (arrToCompare[i] != correctArr[i]) { //checks if there is an inequality
			failureTriggered = true; //if there is, there is a failure. The details of the failure are added to the failure string.
			let reportStringLine = 
			'Block ' + (i+1) + ' (' + plainArr[i] + ') returned ' + arrToCompare[i] + ' instead of ' + correctArr[i] + '.\n';
			//details include the block number, the plaintext block, the generated ciphertext block, and the correct ciphertext block
			reportString += reportStringLine;
		} else {
			let reportStringLine = 'Block ' + (i+1) + ' (' + plainArr[i] + ') returned ' + arrToCompare[i] + ' which is correct.\n';
			reportString += reportStringLine;
		}
	}
	if (failureTriggered)
		return reportString; //returns the failure string if there was a failure
	else
		if (plainLonger) //if the plaintext was longer than the ciphertext, the program will notify the user as such
			return "This square works but the ciphertext is shorter than the plaintext. Make sure the ciphertext is correct.";
		else
			return "This square works!";
}

function comparePlainToCipher() { //lists both the plaintext blocks and ciphertext blocks side-by-side to make them easier to compare
	let plainArr = strToBlocks(plain.value, false);
	let cipherArr = strToBlocks(cipher.value, true);
	if (!cipherArr)
		return;
	let iterator = 0; //this is the iterator that the loops use to determine when to stop
	let outputString = "Blocks:\n\n";
	if (plainArr.length > cipherArr.length) //this determines which array to use for the length comparison in the loop
		iterator = cipherArr.length; //the cipher array's length is used when the plaintext is longer than the ciphertext
	else
		iterator = plainArr.length; //the plain array's length is used when both are equal or when the ciphertext is longer
	for (let i = 0; i < iterator; i++) {
		let line = plainArr[i] + " " + cipherArr[i] + "\n"; //puts both blocks on a line
		outputString += line; //adds the line to the output
	}
	if (plainArr.length > iterator) { //if the plaintext and ciphertext are not of equal length, this statement will output the remaining blocks
		for (let i = iterator; i < plainArr.length; i++) {
			let line = plainArr[i] + "\n";
			outputString += line;
		}
	} else if (cipherArr.length > iterator) {
		for (let i = iterator; i < cipherArr.length; i++) {
			let line = "   " + cipherArr[i] + "\n";
			outputString += line;
		}
	}
	outputString += "\nPlaintext is on the left and ciphertext is on the right. Copy the blocks to another program before closing this message.";
	window.alert(outputString); //a message is added at the bottom and the string is displayed as an alert
}

function findLetter(letter) { //finds the letter passed in on the square
	if (letter == 'J')
		letter = 'I';
	for (let i = 0; i < square.length; i++) { 
		let result = square[i].indexOf(letter); //searches each subarray to find the letter
		if (result != -1) //if the letter was found, something other than -1 is returned
			return [i, result];
	}
	return;
}

function strToBlocks(instr, isCipher) { //converts the input string to two letter blocks while applying padding as needed
	let newString = ""; //this will contain the input string after it has been simplified
	let padding = 'X'; //this gets the padding letter from the textbox for use later
	let altPadding = 'Z'; //this gets the alternate padding letter in the event the padding letter needs to be padded
	for (let x of instr) {
		if (x.match(/[A-Za-z]/i))
			newString += x.toUpperCase(); //this filters out non-alphabetic characters, uppercases the alphabetic characters, and adds them to the newString variable
	}
	let currentBlock = ""; //holds each block as they are being made
	let atSecondChar = false; //tells the program whether to continue or end a block. Needed for when duplicate characters occur and padding is used.
	let stringArr = []; //the array that holds all the blocks and what is ultimately returned
	for (let i = 0; i < newString.length; i++) {
		if (!atSecondChar) { //when the loop is on an even character, the character gets added to the block without any checks
			currentBlock += newString[i];
			atSecondChar = true;
		} else { //when the loop is on an odd character, checks need to be made to ensure blocks are produced correctly
			if (newString[i] == currentBlock) { //checks if the current character is the same as one in the current block to determine if padding is needed
				if (isCipher) {
					window.alert("The ciphertext has a double letter block! Ciphertext should never have a double letter block.");
					return false; //applying padding to ciphertext should never happen so the function is exited early
				} else if (newString[i] != padding) //ensures that the letter is not equal to the padding letter so that a duplicate letter block is not created
					currentBlock += padding; //if they are not equal, then it is fine to apply the padding letter
				else
					currentBlock += altPadding; //if they are equal, the alternate padding letter needs to be utilized
				stringArr.push(currentBlock);
				i -= 1; //decrements the loop iterator as the current letter needs to be reprocessed
			} else {
				currentBlock += newString[i]; //if it is not, the current character gets added to the block and the block is put on the array
				stringArr.push(currentBlock);
			}
			atSecondChar = false; //sets atSecondChar to false regardless of the above code as the program needs to treat characters pushed off because of duplicates as the first character in a new block
			currentBlock = ""; //currentBlock is reset to prevent old blocks from getting into new ones
		}
	}
	if (currentBlock.length != 0 && !cribCheck.checked) { //after the loop finishes, the current block is checked to see if it is not empty to determine if padding is needed and also check if the plaintext is a crib or not
		if (currentBlock != padding) //does the same padding check as above to prevent duplicate letter blocks
			currentBlock += padding;
		else
			currentBlock += altPadding;
		stringArr.push(currentBlock);
	}
	return stringArr;
}

function makeSquare() { //this takes the characters in the square textboxes and puts them into an array the program can use
	square = [];
	usedLetters = []; //keeps track of the letters used in the square so searching for a letter is simpler
	for (let i = 0; i < 5; i++) { //iterates over every row
		let row = []; //every row is built as a seperate array and then added to the square once fully built
		for (let j = 0; j < 5; j++) { //iterates over every column
			let letter = document.getElementById("t" + i + j).value.toUpperCase();
			//this line grabs the value from the corresponding textbox by forming an ID with "t" + i + j. This ID will correspond to a
			//textbox that is defined in the HTML page. It gets the value from the textbox and converts it to uppercase.
			if (letter == 'J') //this converts the letter j into the letter i to prevent errors related to i and j sharing a space
				letter = "I";
			if (letter.match(/[A-Z]/i)) { //verifies that the entered character is a letter and not anything else
				if (usedLetters.indexOf(letter) != -1) { //checks if the current letter is present on the square
					window.alert("There is a duplicate letter on the sqaure! Make sure that there are no duplicates. (J is counted as I so both cannot exist on the table at the same time)");
					//if it is, there is a duplicate
					return false; //an alert is displayed and the function is exited early
				}
				row[j] = letter; //otherwise, the letter is pushed to the row
				usedLetters.push(letter); //the letter is then added to the usedLetters list
			} else {
				window.alert("One of the characters on the square is invalid or the square is not completely filled!");
				return false; //if not, an alert is displayed and the function is exited early
			}
		}
		square[i] = row; //once the row is filled, the row is put onto the table
	}
	return true; //if there were no abnormalities, the function returns true
}

function formSquareFromKeyword() { //this function forms a Playfair square from a keyword inputted by the user. This does not put it into the square array, this is done when the makeSquare function runs.
	let alphabet = ['A','B','C','D','E','F','G','H','I','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];
	//alphabet is used for filling the remainder of the square once the keyword is added
	let newAlphabet = []; //this will contain the keyword and then the alphabet
	for (let x of keywordBox.value.toUpperCase()) {
		if (x.match(/[A-Z]/i)) { //prevents non-alphabetic characters from being considered part of the keyword
			if (x == 'J') //changes the letter j to i since the alphabet array does not contain j
				x = "I";
			if (newAlphabet.indexOf(x) == -1) //checks to see if the current letter has not been used
				newAlphabet.push(x); //if the letter has not been used, it is pushed to the new alphabet
		}
	}
	for (let x of alphabet) { //adds the rest of the alphabet to the new alphabet
		if (newAlphabet.indexOf(x) == -1)
			newAlphabet.push(x);
	}
	let iterator = 0; //keeps track of where in the new alphabet the program is at
	for (let i = 0; i < 5; i++) {
		for (let j = 0; j < 5; j++) {
			document.getElementById("t" + i + j).value = newAlphabet[iterator];
			iterator++;
			//Forms an ID which corresponds to a table textbox. Takes the next letter in the new alphabet according to the iterator and puts it in the textbox. Increments the iterator to ensure no duplicate letters.
		}
	}
}

function resetButton() { //sets all values back to defaults
	plain.value = "";
	cipher.value = "";
	generated.value = "";
	keywordBox.value = "";
	cribCheck.checked = false;
	for (let i = 0; i < 5; i++) {
		for (let j = 0; j < 5; j++) {
			document.getElementById("t" + i + j).value = "";
		}
	}
}

function clearSquare() { //resets only the square
	for (let i = 0; i < 5; i++) {
		for (let j = 0; j < 5; j++) {
			document.getElementById("t" + i + j).value = "";
		}
	}
}

var square = [0]; //square is initialized into a default state. This is changed via makesquare when the user presses the confirm button.
var confirm = document.getElementById("confirm"); //the check button will begin the enciphering/deciphering process
confirm.addEventListener("click", checkButton); //the check button is the confirm button from the encipher/decipher section
var plain = document.getElementById("plain"); //this contains the plaintext inputted by the user
var cipher = document.getElementById("cipher"); //this contains the ciphertext inputted by the user
var generated = document.getElementById("generated"); //this contains the generated ciphertext for ease of comparison
var reset = document.getElementById("reset"); //the reset button will reset all modifiable elements (textboxes, radio buttons) to their default state
reset.addEventListener("click", resetButton)
var compareButton = document.getElementById("compare"); //this lets the user see the two-letter blocks for both plain and ciphertext side-by-side
compareButton.addEventListener("click", comparePlainToCipher);
var clearSquareButton = document.getElementById("squareclear"); //lets the user clear the square only and not all textboxes
clearSquareButton.addEventListener("click", clearSquare);
var keywordBox = document.getElementById("keyword"); //this contains the keyword used to form a square
var keywordButton = document.getElementById("keywordconfirm"); //this tells the program to form a square from the keyword
keywordButton.addEventListener("click", formSquareFromKeyword);
var cribCheck = document.getElementById("crib"); //this tells the program whether the plaintext is a crib so it knows if it needs to apply padding